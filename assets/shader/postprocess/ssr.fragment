// Screen Space Reflections shader by Toni Sagrista
// License: MPL2
#version 330 core

#include shader/lib_logdepthbuff.glsl

// Color buffer
uniform sampler2D u_texture0;
// Depth buffer
uniform sampler2D u_texture1;
// Normal buffer
uniform sampler2D u_texture2;
// Reflection mask
uniform sampler2D u_texture3;

// Camera projection matrix
uniform mat4 u_projection;
// Camera inverse projection matrix
uniform mat4 u_invProjection;
// Z-far and K values for depth buffer
uniform vec2 u_zfark;

// INPUTS
in vec2 v_texCoords;

// OUTPUTS
layout (location = 0) out vec4 fragColor;

#define STEPS 50

vec3 CalcViewPosition(in vec2 TexCoord) {
    // Combine UV & depth into XY & Z (NDC)
    float depth                     = 1.0 / recoverWValue(texture(u_texture1, TexCoord).r, u_zfark.x, u_zfark.y); // Logarithmic depth buffer
    vec3 rawPosition                = vec3(TexCoord, depth);

    // Convert from (0, 1) range to (-1, 1)
    vec4 ScreenSpacePosition        = vec4(rawPosition * 2.0 - 1.0, 1.0);

    // Undo Perspective transformation to bring into view space
    vec4 ViewPosition               = u_invProjection * ScreenSpacePosition;

    // Perform perspective divide and return
    return                          ViewPosition.xyz / ViewPosition.w;
}
vec2 raymarch(vec3 dir, inout vec3 hitCoord, out float dDepth) {
    dir *= 0.25f;

    for(int i = 0; i < STEPS; ++i) {
        hitCoord               += dir;

        vec4 projectedCoord     = u_projection * vec4(hitCoord, 1.0);
        projectedCoord.xy      /= projectedCoord.w;
        projectedCoord.xy       = projectedCoord.xy * 0.5 + 0.5;

        float depth             = CalcViewPosition(projectedCoord.xy).z;
        dDepth                  = hitCoord.z - depth;

        if(dDepth < 0.0)
        return projectedCoord.xy;
    }

    return vec2(0.0f);
}


void main(void) {
    float mask                      = texture(u_texture3, v_texCoords).r;
    vec3 col                        = texture(u_texture0, v_texCoords).rgb;
    if (mask > 0.0) {
        // SSR
        vec3 View_Normal            = texture(u_texture2, v_texCoords).xyz;
        vec3 View_Pos               = CalcViewPosition(v_texCoords).xyz;

        // Reflection vector
        vec3 reflected              = normalize(reflect(normalize(View_Pos.xyz), normalize(View_Normal)));

        // Ray cast
        vec3 hitPos                 = View_Pos.xyz;
        float dDepth;
        float minRayStep            = 0.5e-10;
        vec2 coords                 = raymarch(reflected * max(minRayStep, -View_Pos.z), hitPos, dDepth);

        fragColor                   = vec4(col + textureLod(u_texture0, coords, 0).rgb * mask, 1.0);
    } else {
        // Non-reflective parts
        fragColor                   = vec4(col, 1.0);
    }
}
