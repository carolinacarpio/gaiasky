// Screen Space Reflections shader by Toni Sagrista
// License: MPL2
#version 330 core

// Color buffer
uniform sampler2D u_texture0;
// Depth buffer
//uniform sampler2D u_texture1;
// Normal buffer
uniform sampler2D u_texture2;
// Reflection mask
uniform sampler2D u_texture3;
// Position buffer
uniform sampler2D u_texture4;

// Camera position
uniform vec3 u_pos;
// Camera projection-view (combined) matrix
uniform mat4 u_modelView;
// Camera projection matrix
uniform mat4 u_projection;
// Viewport
uniform vec2 u_viewport;
// Z-far and K values for depth buffer
uniform vec2 u_zfark;

// INPUTS
in vec3 v_ray;
in vec2 v_texCoords;

// OUTPUTS
layout (location = 0) out vec4 fragColor;


vec4 ssr() {
    float maxDistance = 1.0e-7;
    float resolution  = 1.0;
    int   steps       = 10;
    float thickness   = 1.0e-10;

    vec2 texSize  = textureSize(u_texture4, 0).xy;
    vec2 texCoord = gl_FragCoord.xy / texSize;

    vec4 uv = vec4(0.0);

    vec4 positionFrom = texture(u_texture4, texCoord);

    if (  positionFrom.w <= 0.0 ) { return uv; }

    vec3 unitPositionFrom = normalize(positionFrom.xyz);
    vec3 normal           = texture(u_texture2, texCoord).xyz;
    vec3 pivot            = normalize(reflect(unitPositionFrom, normal));

    vec4 positionTo = positionFrom;

    // Start and end point of reflection ray
    vec4 startView = vec4(positionFrom.xyz + (pivot *         0.0), 1.0);
    vec4 endView   = vec4(positionFrom.xyz + (pivot * maxDistance), 1.0);

    vec4 startFrag = startView;
    // Project to screen space
    startFrag      = u_projection * startFrag;
    // Perform perspective divide
    startFrag.xyz /= startFrag.w;
    // Convert the screen-space XY coordinates to UV coordinates
    startFrag.xy   = startFrag.xy * 0.5 + 0.5;
    // Convert the UV coordinates to fragment/pixel coordinates
    startFrag.xy  *= texSize;

    vec4 endFrag = endView;
    endFrag      = u_projection * endFrag;
    endFrag.xyz /= endFrag.w;
    endFrag.xy   = endFrag.xy * 0.5 + 0.5;
    endFrag.xy  *= texSize;

    vec2 frag  = startFrag.xy;
    uv.xy = frag / texSize;

    float deltaX    = endFrag.x - startFrag.x;
    float deltaY    = endFrag.y - startFrag.y;
    float useX      = abs(deltaX) >= abs(deltaY) ? 1.0 : 0.0;
    float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0.0, 1.0);
    vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);

    float search0 = 0;
    float search1 = 0;

    int hit0 = 0;
    int hit1 = 0;

    float viewDistance = startView.y;
    float depth        = thickness;

    float i = 0;

    for (i = 0; i < int(delta); ++i) {
        frag      += increment;
        uv.xy      = frag / texSize;
        positionTo = texture(u_texture4, uv.xy);

        search1 =
        mix
        ((frag.y - startFrag.y) / deltaY
        , (frag.x - startFrag.x) / deltaX
        , useX
        );

        search1 = clamp(search1, 0.0, 1.0);

        viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);
        depth        = viewDistance - positionTo.y;

        if (depth > 0 && depth < thickness) {
            hit0 = 1;
            break;
        } else {
            search0 = search1;
        }
    }

    search1 = search0 + ((search1 - search0) / 2.0);

    steps *= hit0;

    for (i = 0; i < steps; ++i) {
        frag       = mix(startFrag.xy, endFrag.xy, search1);
        uv.xy      = frag / texSize;
        positionTo = texture(u_texture4, uv.xy);

        viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);
        depth        = viewDistance - positionTo.y;

        if (depth > 0 && depth < thickness) {
            hit1 = 1;
            search1 = search0 + ((search1 - search0) / 2);
        } else {
            float temp = search1;
            search1 = search1 + ((search1 - search0) / 2);
            search0 = temp;
        }
    }

    float visibility = hit1
        * positionTo.w
        * (1 - max (dot(-unitPositionFrom, pivot) , 0 ) )
        * (1 - clamp (depth / thickness , 0 , 1 ) )
        * (1 - clamp (length(positionTo - positionFrom) / maxDistance , 0 , 1 ) )
        * (uv.x < 0 || uv.x > 1 ? 0 : 1)
        * (uv.y < 0 || uv.y > 1 ? 0 : 1);
    visibility = clamp(visibility, 0, 1);

    uv.ba = vec2(visibility);
    //return clamp(texture(u_texture0, uv.xy), 0.0, 1.0);
    return vec4(normal, 1.0);
}

void main(void) {
    vec3 reflectionMask = texture(u_texture3, v_texCoords).xyz;
    if (reflectionMask.x == 1.0) {
        fragColor = ssr();

        // Visualize normals
        // vec3 col = texture(u_texture0, v_texCoords).xyz;
        //fragColor = vec4(reflectionMask * normal + (1.0 - reflectionMask.x) * col, 1.0);
    } else {
        // Non-reflective parts
        fragColor = vec4(texture(u_texture0, v_texCoords).xyz, 1.0);
    }
}
